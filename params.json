{"name":"Quick Development Web Server With LINQPad and WebApi Attribute Routing","tagline":"Rapidly prototype an HTTP client application by defining server responses to complex requests.","body":"When writing an HTTP client application, you often need to test unusual server responses that, while in a known format, require you to twist some knobs to force a strange response. Maybe it requires you to register an account on the server and submit various content requests, all of which may take some time if the server you're using requires explicit approval or is processed every X hours. Instead, let's serve up canned responses to the requests you'll be generating!\r\n\r\nMy first instinct would be to create a folder representing the path you want, drop some html/json/xml files in, and power up Python's [SimpleHTTPServer](http://www.linuxjournal.com/content/tech-tip-really-simple-http-server-python) then point your app to `http://localhost:8080` instead of your normal development server. While this works for simple cases, there are three major downsides to this approach:\r\n\r\n1. Static pages only. If you want to test a range of URLs that fit a pattern or debug/validate the query string sent by your application, it's not simple to do without creating tons of duplicate files or trawling through the console log for the request URL.\r\n2. Complex URLs are a pain. To check \"http://someserver.com/some/complex/path/20283\" you need to create a nested directory structure and an index.html just for a single request.\r\n3. Only responds to GET requests. This complaint is specific to `SimpleHTTPServer`: other servers may respond to any HTTP verb, but it's rare that any API-consuming application is limited to just GET requests.\r\n\r\nTo overcome these hurdles, we can turn to the fantastic .Net scratchpad [LINQPad](http://www.linqpad.net/). It's a free program that lets you execute C#/VB statements and make requests to SQL servers, LINQ-to-SQL style. In addition, we'll load up with self-hosted ASP.Net WebApi and Attribute Routing to give us almost infinite flexibility in how we define our responses.\r\n\r\nOnce you have LINQPad installed and open, we need to set up our dependencies. I have the Premium version which comes with NuGet integration, but the required DLLs can be downloaded elsewhere and referenced explicitly if you're using the free version. Now press F4 and add the following references:\r\n\r\n* Microsoft.AspNet.WebApi.OwinSelfHost\r\n* AttributeRouting.WebApi.Hosted\r\n* System.Net.Http.dll\r\n* System.Windows.Forms.dll (if you want a quick \"stop server\" button)\r\n\r\nAnd the following namespace imports:\r\n\r\n* AttributeRouting\r\n* Microsoft.Owin.Hosting\r\n* Owin\r\n* System.Net.Http\r\n* System.Web.Http\r\n* System.Web.Http.Dispatcher\r\n* System.Web.Http.SelfHost\r\n* System.Windows.Forms\r\n* System.Net\r\n\r\nNow change your snippet's Language to `C# Program`, which will allow us to define our own methods and classes to setup WebApi. \r\n\r\nFirst bit of code you can straight copy-paste into the panel. Since LINQPad generates your defined classes nested within its own UserQuery class, WebApi's default ControllerTypeResolver cannot find our controller. This class will reset the resolver so that it can find our code. Major thanks to [StrathWeb](http://www.strathweb.com/2013/04/hosting-asp-net-web-api-in-linqpad/) for the tip.\r\n\r\n    public class ControllerResolver : DefaultHttpControllerTypeResolver \r\n    {\r\n        public override ICollection<Type> GetControllerTypes(IAssembliesResolver assembliesResolver) \r\n        {\r\n            var types = Assembly.GetExecutingAssembly().GetExportedTypes();\r\n            return types.Where(i => typeof(System.Web.Http.Controllers.IHttpController).IsAssignableFrom(i)).ToList();          \r\n        }\r\n    }\r\n\r\nNow, we can define a \"startup\" class responsible for configuring WebApi. Note that we replace the original controller resolver here and map our (future) attribute routes here.\r\n\r\n    public class Startup\r\n    {\r\n        public void Configuration(IAppBuilder appBuilder)\r\n        {\r\n            var config = new HttpConfiguration();\r\n            \r\n            // LINQPad generates nested classes, not\r\n            // detectable by default resolver.\r\n            config.Services.Replace(\r\n                typeof(IHttpControllerTypeResolver), \r\n                new ControllerResolver());\r\n                \r\n            config.MapHttpAttributeRoutes();\r\n            appBuilder.UseWebApi(config);\r\n        }\r\n    }\r\n\r\nHere's our `Main` function which will be responsible for starting and tearing down our self-hosted server. One really neat feature of LINQPad is that it doesn't necessarily tear down your process once the script is done. You can [inject UI controls](http://www.linqpad.net/customvisualizers.aspx) into the output panel to allow interactive execution of your scripts. We'll be using a Button to give us control over when our web server shuts down.\r\n\r\n    void Main()\r\n    {\r\n        var baseAddress = \"http://localhost:8080\";\r\n        var app = WebApp.Start<Startup>(baseAddress);\r\n        \r\n        var button = new Button { Text = \"Click to stop server.\" };\r\n        var panel= PanelManager.DisplayControl(button, \"Webserver\");\r\n        \r\n        button.Click += (o, e) =>\r\n        {\r\n            app.Dispose();\r\n            panel.Close();\r\n        };\r\n    }\r\n\r\nNow for the meat of the script, our **ApiController!** Let's say, for example, that we are making two HTTP calls:\r\n\r\n* One POST request to `/some/complex/path/123?cc=no` where `123` is variable and the `cc` value tells us that our country is Norway. It will return a basic static HTML file.\r\n* A GET request to `/some/other/path` that will return a `500` error simulating catastrophic failure on the server.\r\n\r\nUnder normal WebApi, these nested paths would probably require some complex route configuration, but with the new Attribute Routing it's all handled automagically based on the route we define for our Action method. Here's what our controller will look like:\r\n\r\n    public class MainController : ApiController\r\n    {\r\n        [Route(\"some/complex/path/{id}\")]\r\n        // WebApi parameter binding will turn {id} in the path into an argument and\r\n        // pull 'lc' and 'cc' from the query string (with default values) automatically.\r\n        public HttpResponseMessage Post(string id, string lc = \"en\", string cc = \"us\")\r\n        {\r\n            // Print some debug data during the request.\r\n            // Will appear in Results panel.\r\n            (lc + \"-\" + cc).Dump();\r\n            return StaticFile(\"c:/users/dan/somedoc.html\");\r\n        }\r\n        \r\n        [Route(\"some/other/path\")]\r\n        // Note that, using WebApi, defining the HTTP Verb used for a particular\r\n        // action is based on the name of the method.\r\n        public string Get()\r\n        {\r\n            throw new HttpResponseException(HttpStatusCode.InternalServerError);\r\n        }\r\n    }\r\n\r\nTo finish things up here's the implementation of `StaticFile`, a method that reads a file from disk and returns it as HTML:\r\n\r\n    private static HttpResponseMessage StaticFile(string localFilename, string contentType = \"text/html\")\r\n    {\r\n        if(File.Exists(localFilename))\r\n        {\r\n            return new HttpResponseMessage(HttpStatusCode.OK)\r\n            {\r\n                Content = new StringContent(\r\n                        File.ReadAllText(localFilename),\r\n                    Encoding.UTF8, contentType)\r\n            };\r\n        }\r\n        else\r\n        {\r\n            return new HttpResponseMessage(HttpStatusCode.NotFound)\r\n            {\r\n                Content = new StringContent(\"File \" + localFilename + \" does not exist.\")\r\n            };\r\n        }\r\n    }\r\n\r\nNow click the Run button and try it out! Take a look at the nice, big button that you can click when you're ready to turn off the web server:\r\n\r\n![Stop Button](http://i.imgur.com/4iuTuVt.png)\r\n\r\nYou can save this whole snippet as a Query or a Sample and modify the Controller to return whatever data your heart desires next time you need it for testing.","google":"UA-46278645-1","note":"Don't delete this file! It's used internally to help with page regeneration."}